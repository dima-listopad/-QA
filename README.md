## 1. Тестирование и STLC. Принципы тестирования

Тестирование ПО (software testing) – процесс анализа программного средства и сопутствующей документации с целью выявления дефектов и повышению качества продукта.

Жизненный цикл тестирования ПО (Software Testing Lifecycle) - это последовательность действий, проводимых в процессе тестирования, с помощью которых гарантируется качество программного обеспечения и его соответствие требованиям.

Фазы STLC:
1.	Анализ требований (Requirement Analysis): один из важнейших этапов, потому что именно на нем можно почти бесплатно исправить недостатки проекта;
2.	Планирование тестирования (Test Planning): на этом этапе формируется план тестирования, т.е. мы определяем действия и ресурсы, которые помогут достичь целей тестирования;
3.	Разработка тест-кейсов (Test Case Development): выявление всех возможных случаев использования продукта, его характеристик и особенностей в процессе эксплуатации;
4.	Настройка тестовой среды (Test Environment Setup): настраиваются операционные системы и виртуальные машины, инструменты тестирования, также обращаемся с запросами к DevOps и администраторам, если требуется поддержка;
5.	Выполнение тестов (Test Execution): тесты выполняются на основе готовой тестовой документации и правильно настроенной тестовой среды;
6.	Завершение цикла испытаний (Test Cycle Closure): окончательная генерация отчетов о тестировании для клиента.

Принципы тестирования:
1.	Тестирование показывает наличие дефектов (Testing shows presence of defects) - Тестирование может показать, что дефекты присутствуют, но не может доказать, что дефектов больше нет;
2.	Исчерпывающее тестирование невозможно (Exhaustive testing is not possible) - Для проведения исчерпывающего тестирования придется протестировать все возможные входные значения и все пути выполнения программы, в большинстве случаев число таких вариаций стремится к бесконечности или просто на порядки превосходит отведенное время и бюджет;
3.	Раннее тестирование (Early testing) - Тестовые активности должны начинаться как можно раньше в SDLC, а именно когда сформированы требования;
4.	Скопление дефектов (Defect clustering) - Это может происходить потому, что определенная область кода особенно сложна и запутана, или потому, что внесение изменений производит «эффект домино»;
5.	Парадокс пестицида (Pesticide paradox) - Это эффект, при котором при регулярном прогоне тестовых сценариев ошибки перестают находиться;
6.	Тестирование зависит от контекста (Testing is context dependent) - Тестирование проводится по-разному в зависимости от контекста. Например, программное обеспечение, в котором критически важна безопасность, тестируется иначе, чем новостной портал;
7.	Заблуждение об отсутствии ошибок (Absence of errors fallacy) - Отсутствие найденных дефектов при тестировании не всегда означает готовность продукта к релизу. Система должна быть удобна пользователю в использовании и удовлетворять его ожиданиям и потребностям.

## 2. Виды тестирования

По объекту тестирования:
1.	Функциональное тестирование (functional testing) – проверка того что продукт обладает всем функционалом, который описан в требованиях;
2.	Нефункциональное тестирование (Non-Functional testing) - тестирование свойств, которые не относятся к функциональности системы:
  - Инсталляционное (installation testing) – установка, обновление, удаление;
  - Конфигурационное тестирование (configuration testing) – проверку работы ПО при различных конфигурациях системы (ОС, устройства, версиях браузеров);
  - Тестирование совместимости (compatibility testing) – проверка работы приложения на разных окружениях (кроссбраузерное и кроссплатформенное тестирование);
  - Тестирование удобства использования (usability testing) – тестирование направлено на удобство и понятность работы с приложением;
  - (i18n) Тестирование интернационализации (internationalization testing) – тестирование перевода на разные языки;
  - (l10n) Тестирование локализации (localization testing) – процесс адаптации нашего продукта к языку и культуре, формат даты и времени, правовые особенности, раскладка клавиатуры, контроль символики и цветов клиента;
  - Тестирование безопасности (security testing) – тестируем защищённость нашего программного продукта;
  - Тестирование интерфейса (interface testing) - проверки того, соответствует ли пользовательский интерфейс ПО требованиям;
  - Тестирование доступности (accessibility testing) – тестирование для людей с ограниченными возможностями, также для тех кто ограничен в своих возможностях (к примеру в момент когда человек за рулем);
  - Тестирование производительности (performance testing) – определяет работу вычислительной системы под определённой нагрузкой:
    - Нагрузочное тестирование (load testing) - проверяет способность приложения работать при ожидаемой рабочей нагрузке;
    - Стресс (stress) – проверяем что происходит с продуктом при высоких нагрузках;
    - Стабильность (stability) – тестируем работу сайта с определенными нагрузками в течении определённого времени;
    - Объемное (Volume testing) – проверка на передачу больших объемов информации;
    - Тестирование на отказ и восстановление (failover and recovery testing) – проверка на восстановление после ошибок и сбоев.

Тестирование, связанное с изменениями:
1.	Дымовое тестирование (smoke test) – проверка самого важного функционала продукта;
2.	Регрессионное тестирование (regression testing) –проверка того, что не нарушилась работоспособность работающей ранее функциональности, если её код мог быть затронут при использовании некоторых дефектов в другой функциональности;
3.	Тестирование сборки (build verification test) – тестирование на соответствие критериям качества новой сборки;
4.	Санитарное тестирование (sanity test) – это тестирование отдельной функциональности.

По исполнению сценария:
1.	Исследовательское тестирование (exploratory testing) – одновременно изучение проекта, функционала, проектирование тест кейсов в уме и тут же их исполнение не записывая и не создавая тестовую документацию;
2.	Свободное тестирование (ad-hoc testing) – импровизация без документации;
3.	Сценарное тестирование (scenario testing) – тестирование по заранее задокументированному сценарию.

По степени важности:
1.	Дымовой тест (smoke test) – проверка самого важного функционала продукта;
2.	Тест критического пути (critical path test) – проверяются типичные задачи продукта;
3.	Расширенный тест (extended test) – всё оставшееся что не проверяли в smoke и critical.

По цели тестирования:
1.	Тестирование новой функциональности (new feature test) – тестирование новой функциональности, которая ранее не тестировалась;
2.	Регрессионное тестирование (regression testing) – проверка того, что не нарушилась работоспособность работающей ранее функциональности, если её код мог быть затронут при исправлении некоторых дефектов в другой функциональности;
3.	Подтверждающее тестирование (re-test) - тестирование, с целью подтвердить успешность исправлений дефекта.

По направлению тестирования (По запуску кода):
1.	Статическое тестирование (static testing) (без запуска программы) – тестирование документации, дизайн. Если опытный программист, то глазами посмотреть код;
2.	Динамическое тестирование (dynamic testing) (с запуском программы).

По методу тестирования:
1.	Метод белого ящика (white box testing) - тестировщик имеет доступ к коду (unit test – это тестирование отдельного участка кода);
2.	Метод черного ящика (black box testing) - тестировщик не имеет доступа к коду (GUI);
3.	Метод серого ящика (grey box testing) - к части кода доступ есть, а к части нет (UI, dev tools, Postman).

По уровню тестирования:
1.	Компонентное (component testing) – это тестирование отдельного модуля (обычно unit test делает разработчик);
2.	Интеграционное (integration testing) - проверка взаимодействия модулей;
3.	Системное (system testing) - полная проверка приложения;
4.	Приемочное (acceptance testing) - вид тестирование на этапе сдачи готового продукта или его части.

По позитивности:
1.	Позитивное (positive testing) - тестирование которое соответствует нормальному поведению системы;
2.	Негативное (negative testing) - применяются сценарии которые соответствуют нештатному поведению системы.

По степени автоматизации:
1.	Ручное (manual testing) – тестировщики выполняют тесты не используя средств автоматизации;
2.	Автоматизированное (automated testing) – с использованием ПО.

По исполнителю тестирования:
1.	альфа-тестирование (alpha testing) - проверка программного продукта на поздней стадии, разработчиками;
2.	бета-тестирование (beta testing) - оценка ПО перед выходом на рынок в фокус-группе или добровольцами.

## 3. QA, QC и тестирование. Верификация и валидация 

Три уровня работы с качеством программного обеспечения:

- Специалист по тестированию занимается выполнением тестов. Тестированием называют проверку соответствия результатов работы программного продукта на соответствие заданным критериям. Тестировщики занимаются тестированием всего продукта в целом или же отдельных компонентов. 

- QC (Quality Control) — контроль качества продукта. Задача QC-специалиста — проверка конкретного продукта, что включает анализ кода продукта, дизайна, плюс тестирование. QC-инженер разрабатывает стратегию тестирование вполне определенного тестирования, взаимодействует с разработчиками и организует само тестирование.

- QA (Quality Assurance) — обеспечение качества продукта. QA-специалист контролирует и обеспечивает качество работы продукта компании. Он отвечает и за отдельные этапы разработки софта. В частности, за выбор инструментов для разработки, предотвращение возможных проблем. Еще он участвует в процессе совершенствования продукта. QA охватывает все этапы разработки, включая описание проекта, собственно, тестирование, релиз и, зачастую, пост-релизный этап.

Верификация - это проверки, выполняемые в процессе разработки ПО для ответа на вопрос: “правильно ли мы разрабатываем продукт? (Верификация всегда происходит до валидации)

Валидация - это процесс оценки конечного продукта, чтобы проверить, соответствует ли он потребностям бизнеса и ожиданиям клиентов, т.е. отвечает на вопрос: “правильный ли мы разработали продукт?”

Понять, что тестировщик выполнил свою работу хорошо можно по факту выполнения следующих задач:
- продукт проверен на соответствие требованиям;
- сведено к минимуму количество дефектов, которые обнаружит конечный пользователь;
- предоставлена отчетность по актуальному качеству продукта и любых остаточных рисках заинтересованным лицам.

## 4. SDLC. Модели разработки ПО
Жизненный цикл ПО (Software Development Life Cycle) – это период времени который начинается когда принимаются решение о том что нам надо сделать ПО и заканчивается выводом его из эксплуатации.

Идея → Сбор и анализ требований (сбор требований к разрабатываемому программному обеспечению; их систематизацию; документирование; анализ; выявление и разрешение противоречий) → Архитектура и дизайн (программисты и системные архитекторы, руководствуясь требованиями, разрабатывают высокоуровневый дизайн системы) → Разработка и тестирование (разработка алгоритмов – создание логики работы программы; написание исходного кода; компиляция – преобразование в машинный код; тестирование и отладка – юнит-тестирование) → Релиз (когда продукт доступен конечному пользователю) → поддержка (чинятся баги и дописываются новые идеи, чтобы каждый пользователь был счастлив) → вывод из эксплуатации.

МОДЕЛИ РАЗРАБОТКИ ПО:

- Водопадная (waterfall) – суть заключается в том, что мы можем переходить к следующему шагу разработки или тестирования только после того, как предыдущий был успешно завершён. Данная модель разработки подходит для проектов с чётко определёнными требованиями и для которых не предусматривается их изменение в процессе разработки (банковские структуры, медицинские, военные и космические отрасли).
К недостаткам водопадной модели принято относить тот факт, что участие пользователей ПО в ней либо не предусмотрено вообще, либо предусмотрено лишь косвенно на стадии однократного сбора требований. С точки зрения же тестирования эта модель плоха тем, что тестирование в явном виде появляется здесь лишь с середины развития проекта, достигая своего максимума в самом конце.
____
- V-модель –  это усовершенствованная каскадная модель, в которой заказчик с командой программистов одновременно составляют требования к системе и описывают, как будут тестировать её на каждом этапе. Тестирование здесь появляется уже на самых ранних стадиях развития проекта, что позволяет минимизировать риски, а также обнаружить и устранить множество потенциальных проблем до того, как они станут проблемами реальными.
Данная модель обычно используется в проектах где есть временные и финансовые ограничения и для таких задач, которые предполагают более широкое тестовое покрытие.
____
- Итерационная инкрементальная модель (Iterative and incremental model) – Итерационная инкрементальная модель особенностью данной модели является разбиение проекта на относительно небольшие промежутки (итерации), каждый из которых в общем случае может включать в себя все классические стадии. Итогом итерации является улучшение продукта - инкремент, выраженное в промежуточном билде (build).
Длина итераций может меняться в зависимости от множества факторов, однако сам принцип многократного повторения позволяет гарантировать, что и тестирование, и демонстрация продукта конечному заказчику (с получением обратной связи) будет активно применяться с самого начала и на протяжении всего времени разработки проекта. Во многих случаях допускается распараллеливание отдельных стадий внутри итерации и активная доработка с целью устранения недостатков, обнаруженных на любой из (предыдущих) стадий. Итерационная инкрементальная модель очень хорошо зарекомендовала себя на объемных и сложных проектах, выполняемых большими командами на протяжении длительных сроков. Однако к основным недостаткам этой модели часто относят высокие накладные расходы, вызванные высокой «бюрократизированностью» и общей громоздкостью модели.
____
- Спиральная модель (spiral model) - Используя эту модель, заказчик и команда разработчиков серьёзно анализируют риски проекта и выполняют его итерациями. Последующая стадия основывается на предыдущей, а в конце каждого витка — цикла итераций — принимается решение, продолжать ли проект.
Спиральная модель похожа на инкрементную, но здесь гораздо больше времени уделяется оценке рисков. С каждым новым витком спирали процесс усложняется. Эта модель часто используется в исследовательских проектах и там, где высоки риски. Эта модель не подойдет для малых проектов, она для сложных и дорогих, например, таких, как разработка системы документооборота для банка, когда каждый следующий шаг требует большего анализа для оценки последствий, чем программирование.
____
- Agile – это набор методов и принципов гибким управлением проектами. То как мы должны мыслить, какие должны быть ценности, чтобы правильно построить процессы.
Ценности Agile:
1. Люди и взаимодействия важнее процессов и инструментов;
2. Работающий продукт важнее исчерпывающей документации;
3. Сотрудничество с клиентом важнее условий согласования контракта;
4. Готовность к изменению важнее следования первоначального плана.
Методология подходит для больших или нацеленных на длительный жизненный цикл проектов, постоянно адаптируемых к условиям рынка. 
Основополагающие принципы Agile Manifesto:
1. наивысшим приоритетом признается удовлетворение заказчика за счёт ранней и бесперебойной поставки ценного программного обеспечения;
2. изменение требований приветствуется даже в конце разработки (это может повысить конкурентоспособность полученного продукта);
3. частая поставка работающего программного обеспечения (каждые пару недель или пару месяцев с предпочтением меньшего периода);
4. общение представителей бизнеса с разработчиками должно быть ежедневным на протяжении всего проекта;
5. проекты следует строить вокруг заинтересованных людей, которых следует обеспечить нужными условиями работы, поддержкой и доверием;
6. самый эффективный метод обмена информацией в команде — личная встреча;
7. работающее программное обеспечение — лучший измеритель прогресса;
8. спонсоры, разработчики и пользователи должны иметь возможность поддерживать постоянный темп на неопределённый срок;
9. постоянное внимание к техническому совершенству и хорошему проектированию увеличивают гибкость;
10. простота как искусство не делать лишней работы очень важна;
11. лучшие требования, архитектура и проектные решения получаются у самоорганизующихся команд;
12. команда регулярно обдумывает способы повышения своей эффективности и соответственно корректирует рабочий процесс.
Наиболее удачным примером использования Гибкой модели (Agile-model) на сегодняшний день является фреймворк Scrum.
____
- Scrum – это фреймворк для управления проектами. Вся разработка делится на спринты. Вся работа разбивается на итерации, которые называются Спринт (Sprint). Каждый Спринт длиться от 2х до 4х недель.
РОЛИ В SCRIM: 
Development team – это команда работающих над проектом разработчики, тестировщики, бизнес-аналитики. Действет коллективная ответственность; 
Scrum-мастер – человек, который следит, чтобы соблюдались принципы скрама, обучение нового персонала. (не участвует в разработке) Этот человек не руководитель команды, а тренер; 
Product owner – представляет интересы бизнеса, общается непосредственно с заказчиком, выясняет что необходимо и передает эту информацию. представляет клиента, не руководитель команды.
СОБЫТИЯ В SCRUM: 
1. Планирование спринта (Sprint Planning) - это событие в Scrum, которое знаменует начало спринта. В ходе планирования определяется объём работы на спринт и способы выполнения этой работы;
2. Ежедневный Scrum (Daily Scrum) – Что ты делал вчера? Что ты будешь делать сегодня? Какие есть препятствия для выполнения цели?
3. Обзор спринта (Sprint Review) – подводим итоги того что было у нас сделано во время нашего спринта;
4. Ретроспектива (Sprint Retrospective) - проводится в конце спринта. Её суть – выяснить, что можно улучшить исходя из результатов нашей итерации.
АРТЕФАКТЫ В SCRUM:
1. Бэклог продукта (Product Backlog) – это список в котором все задачи для реализации готового продукта;
2. Уточнение бэклога продукта (Product Backlog Refinement) – собирается команда и product owner который представляет вам новый юзер стори который он написал (уточняет интересующие вопросы);
3. Критерии подготовленности (Definition of Ready) – DoR (фокус на уровне бэклога) – помогает заказчику создать хорошо написанные пользовательские истории, которые готовы для разработки;
4. Пользовательские истории (User Stories) – это формулировка намерения, описывающая что-то, что система должна делать для пользователя. As a [Rose], I can [Functionality], So that [Rationale], Acceptance criteria.
5. Покер планирования (Planning poker) – это оценка юзер стори 
6. Бэклог спринта (Sprint Backlog) – выбираем что мы будем реализовывать в данном спринте, перетягиваем из бэклога продукта стори в бэклог спринта;
7. Инкремент продукта (Product Increment) – это всё то что мы разработали до и разработаем в конце данной итерации;
8. Критерии готовности (Definition of Done) – DoD (фокус на уровне спринта или релиза) – помогает проверить работу в соответствии со всеми требованиями проекта, а не только продемонстрировать, что функциональности работают.
МЕТРИКИ SCRUM:
1. Velocity – это скорость нашей команды. Рассчитывается как среднее арифметическое значение завершённых стори поинтов в предыдущих спринтах;
2.Capacity – количество доступного времени членов команды. Рассчитывается: все часы в итерации на каждого штатного разработчика нашей Development команды;
3. Диаграмма сгорания задач (Burndown chart)
4. Накопительная диаграмма потока (Cumulative flow diagram)
____
- Kanban – система, построенная на визуализации процесса выполнения задач команды. Основная идея в системе уменьшать количество задач, выполняемых в данный момент. Задача проходит по всем этапам на доске и как только она выполнена её можно отдавать заказчику. Kanban-доска состоит из колонок каждый из которых это отдельный процесс разработки. Пример: список задач которые нужно сделать, задачи в работе, выполненные задачи, задачи готовые к тестированию, задача протестирована.

## 5. Виды тестовой документации. Тест-кейс vs Чек-лист

Тестовая документация бывает двух видов внешняя и внутренняя:

Внешняя документация:
- Замечание – комментарий о небольшой неточности в реализации продукта;
- Баг-репорт – это технический документ, который содержит в себе полное описание бага;
- Запрос на изменение (улучшение) – описание требований, которые не были учтены при планировании/реализации продукта. И пути/рекомендации по модификации продукта;
- Отчет о тестировании (тест репорт) – документ, предоставляющий сведения о соответствии/ несоответствии продукта требованиям.

Внутренняя документация:
- Тест план (Test Plan) - это документ, описывающий весь объем работ по тестированию, начиная с описания объекта, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения.
(Хороший тест план отвечает на вопросы: Что тестируем? Где тестируем? Когда тестируем? Как тестируем?);
- Тестовый сценарий – последовательность действий над продуктом. Фактически при успешном прохождении всего тестового сценария мы можем сделать заключение о том, что продукт может выполнять ту или иную возложенную на него функцию;
- Тест набор (Test suite) -  набор тест-кейсов, собранных в группу для достижения некоторой цели. (Выполнения каждого являются некоторыми предусловиями для начала выполнения следующего. Тест кейсы идут по порядку);
- Чек-лист (check-list) – набор идей тестов;
- Тест кейс (test case) – набор входных данных, условий выполнения и ожидаемых результатов, разработанный с целью проверки того или иного св-ва или поведение программного средства.  

Атрибуты тест-кейса:
1. Уникальный идентификатор тест-кейса (необходим для удобной организации хранения и навигации по нашим тест-наборам).
2. Название (основная тема, или идея тест-кейса. Кратное описание его сути);
3. Предусловия (описание условий, которые не имеют прямого отношения к проверяемому функционалу, но должны быть выполнены. Например, оставить комментарий на вашем портале может только зарегистрированный пользователь. Значит для тест-кейса «Создание комментария» будет необходимо выполнение предусловия «пользователь зарегистрирован», и «пользователь авторизован»)
4. Шаги (описание последовательности действий, которая должна привести нас к ожидаемому результату);
5. Фактический результат;
6. Ожидаемый результат;
7. Дефект.

Преимущества: простота прохождения, удобство обучения;

Недостатки: долго писать, много копипасты, трудно поддерживать, долго писать.

Атрибуты чек-листа:
1. Версия билда;
2. Окружение;
3. Дата;
4. Автор;
5. Тип тестов;
6. Описание теста;
7. Результат теста.

Преимущества: мало текста, нет копипасты, проще поддерживать, быстрее писать.

Недостатки: малопонятны новичкам, возможное непонимание проверки (может быть непонятен замысел автора той или иной проверки).

## 6. Требования

Требования — это спецификация (описание) того, что должно быть реализовано.

Уровни требований:
1. Бизнес требования (Цель, ради которой создаётся продукт (для чего? Какая польза? Как получить прибыль?));
2. Пользовательские требования (задачи, которые пользователь может выполнять с помощью продукта);
3. Продуктные требования: 
  - Функциональные требования (охватывают предполагаемое поведение системы, определяя действия, которые система способна выполнять. Описывается в системной спецификации. В основном влияют на дизайн системы);
  - Нефункциональные требования (охватывают свойства системы (удобства использования, надежность, масштабируемость) которыми она должна обладать при реализации своего поведения)).

Пути выявления требований:
- Интервью (беседую с заказчиком или пользователями);
- Наблюдение (наблюдая за работой пользователя в похожем продукте или в старой версии и выяснить что их интересует и что нужно улучшить);
- Самостоятельное описание (мы можем самостоятельно написать требования включив здравый смысл);
- Прототипирование (т.е. разрабатывая сайт и у нас есть конкурент, мы можем зайти к нему и посмотреть, как он работает, как реализованы разные функции);

Свойства требований:
- Завершённость (требование должно содержать всю необходимую информацию);
- Непротиворечивость (одни требования не должны противоречить другим);
- Корректность (требование должно четко указывать на то, что должно выполнять приложение);
- Недвусмысленность (точность формулировки в требованиях может по-разному интерпретироваться тестировщиками, разработчиками и другими участниками проекта);
- Проверяемость (требование должно быть проверено на предмет того, выполняется оно или нет. Если мы что-то не можем проверить значит такое требование не нужно записывать);
- Модифицируемость (исправление / внесение правок в требования должно быть простой операцией.);
- Прослеживаемость (возможность отследить связь между требованием и другими артефактами проекта, каждое требование имеет уникальный идентификатор, по которому оно легко прослеживается).

Как упростить работу с требованиями:
- Написать тест-кейсы – когда мы получаем требования мы можем сразу написать тест-кейсы, если мы не можем написать его (мы не можем придумать проверки, которые покрыли бы это требование). В данном случае мы можем обратиться к нашему Product owner чтобы он связался с заказчиком, и они переформулировали это требование, узнали точно ли нужна эта функциональность. 
- Задавать вопросы – самое простое мы обращаемся к нашему аналитику или заказчику (если есть такая возможность) и задаём уточняющие вопросы.
- Нарисовать схему – интеллект-карты (мы берём большое требование и разбиваем его на маленькие функциональности, а их ещё на более мелкие), Use-cases (так называемые варианты использования, которые описывают все действия, которые наш пользователь может произвести и реакцию системы на эти действия).
- Рецензирование – когда кто-то пишет требования и мы выступаем рецензором этого требования.

Способы представления (как они могут выглядеть):
- Use-cases – это перечень действий, сценарий по которому пользователь взаимодействует с приложением, программой для выполнения какого-либо действия для достижения конкретной цели.
- User story - это короткая формулировка намерения, описывающая что-то, что система должна делать для пользователя.
- Ui mockup – требования могут выглядеть непосредственно как mockup, шаблоны нашего ui - которого мы видим на экране.
- Спецификации - документ, устанавливающий требования. 

## 7. Отчет о дефекте. Severity и Priority. ЖЦ дефекта

Баг – это несоответствие фактического результата и ожидаемого.

Баг-репорт – это технический документ, который содержит в себе полное описание бага.
 
Атрибуты баг-репорта:
1. Id (уникальный номер);
2. Summary (оглавление, краткое описание);
3. Environment (окружение);
4. Preconditions (предварительные условия);
5. Step to reproduce (шаги для воспроизводства);
6. Expected result (ожидаемый результат);
7. Actual result (фактический результат);
8. Attachments (картинки, видео, логи – это текстовые файлы, в которых хранится информация о посещениях, параметрах посещений вашего сайта и ошибках, которые возникали на нем);
9. Priority (приоритет);
10. Severity (серьёзность);
11. Status (статус).
 
Серьёзность проблемы:
- Blocker — устанавливается, если баг блокирует дальнейшую работу приложения или процесс тестирования;
- Critical — присваивается при значительном влиянии проблемы на поведение ПО, но без блокировки его работы или процесса тестирования;
- Major — Весьма серьезная ошибка, свидетельствующая об отклонении от бизнес логики или нарушающая работу программы. Не имеет критического воздействия на приложение;
- Minor — Незначительный дефект, не нарушающий функционал тестируемого приложения, но который является несоответствием ожидаемому результату. Например, ошибка дизайна;
- Trivial – Баг, не имеющий влияние на функционал или работу программы, но который может быть обнаружен визуально. Например, ошибка в тексте.
 
Приоритет проблемы:
- High – исправить необходимо в первую очередь;
- Medium – требуется исправить, но не оказывает критическое воздействие на работу приложения;
- Low – исправить в последнюю очередь.
 
Жизненный цикл дефектов:
1. Новый (New). Тестировщик нашел баг, дефект успешно занесен в «Bug-tracking» систему;
2. Открыт (Opened). После того, как тестировщик отправил ошибку, она либо автоматически, либо вручную назначается на человека который должен её проанализировать (обычно Project Manager). В зависимости от решения менеджера проекта, баг может быть:
3. Отложен (Deferred). Исправление этого бага не несет ценности на данном этапе разработки или по другим, отсрочивающим его исправление причинам;
4. Отклонен (Rejected). По разным причинам дефект может и не считаться дефектом или считаться неактуальным дефектом, что вынуждает отклонить его;
5. Дубликат (Duplicate). Если описанная ошибка уже ранее была внесена в «Bug-tracking» систему, то статус такой ошибки меняется на «дубликат»;
6. Назначен (Assigned). Если ошибка актуальна и должна быть исправлена в следующей сборке (build), происходит назначение на разработчика который должен исправить ошибку;
7. Исправлен (Fixed). Ответственный за исправление бага разработчик заявляет, что устранил дефект. В зависимости от того, исправил ли разработчик дефект, дефект может быть:
8. Проверен (Verified). Тестировщик проверяет, действительно ли ответственный разработчик исправил дефект, или все-таки разработчик безответственный. Если бага больше нет, он получает данный статус;
9. Повторно открыт (Reopened). Если опасения тестировщика оправданы и баг в новом билде не исправлен – он все так же потребует исправления, поэтому заново открывается;
10. Закрытый (Closed). В результате определенного количества циклов баг все-таки окончательно устранен и больше не потребует внимания команды – он объявляется закрытым.

## 8. ТЕХНИКИ ТЕСТ-ДИЗАЙНА
 
Тест-дизайн – это этап процесса тестирования ПО, на котором проектируются и создаются тестовые случаи (тест-кейсы) в соответствии с определёнными ранее критериями качества и целями тестирования.
 
Тест-дизайнер должен выстроить процесс тестирования всех важнейших частей программного продукта, используя минимально возможное количество проверок.
 
Методики:
1. Тестирование Классами Эквивалентности (Equivalence Class Testing) - Тестовые данные разбиваются на определенные классы допустимых значений. В рамках каждого класса выполнение теста с любым значением тестовых данных приводит к эквивалентному результату. После определения классов необходимо выполнить хотя бы один тест в каждом классе.
____
2. Тестирование Граничных Значений (Boundary Value Testing) - Эта техника основана на том факте, что одним из самых слабых мест любого программного продукта является область граничных значений. Для начала выбираются диапазоны значений – как правило, это классы эквивалентности. Затем определяются границы диапазонов. На каждую из границ создается 3 тест-кейса: первый проверяет значение границы, второй – значение ниже границы, третий – значение выше границы.
____
3. Таблица Принятия Решений (Decision Table Testing) - способ компактного представления модели со сложной логикой; инструмент для упорядочения сложных бизнес требований, которые должны быть реализованы в продукте. Это взаимосвязь между множеством условий и действий.

В таблицах решений представлен набор условий, одновременное выполнение которых должно привести к определённому действию.
____
4. Тестирование Состояний и Переходов (State-Transition Testing) - Суть заключается в том что любая система находится в различных состояниях и определённые действия приводят к изменению этого состояния (Удобнее нарисовать и стрелками соединит там где должны быть переходы и где нельзя из одного состояния попасть в другое)
____
5. Метод Парного Тестирования (Pairwise testing) - Суть метода не в том, чтобы перебрать все возможные пары параметров, а в том, чтобы подобрать пары, обеспечивающие максимально эффективную проверку при минимальном количестве выполняемых тестов.
____
6. Доменный анализ (Domain Analysis Testing) - Это техника основана на разбиении диапазона возможных значений переменной (или переменных) на поддиапазоны (или домены), с последующим выбором одного или нескольких значений из каждого домена для тестирования. Во многом доменное тестирование пересекается с известными нам техниками разбиения на классы эквивалентности и анализа граничных значений. Но доменное тестирование не ограничивается перечисленными техниками. Оно включает в себя как анализ зависимостей между переменными, так и поиск тех значений переменных, которые несут в себе большой риск (не только на границах).
____
7. Сценарий использования (Use Case Testing) - Use Case описывает сценарий взаимодействия двух и более участников (как правило – пользователя и системы). Пользователем может выступать как человек, так и другая система. Для тестировщиков Use Case являются отличной базой для формирования тестовых сценариев (тест-кейсов), так как они описывают, в каком контексте должно производиться каждое действие пользователя. Use Case, по умолчанию, являются тестируемыми требованиями, так как в них всегда указана цель, которой нужно достигнуть, и шаги, которые надо для этого воспроизвести.

## 9. Интерфейс и его виды

Интерфейс — способ взаимодействия пользователя с программой или программы с программой.

Типы интерфейсов:
1. Пользовательский интерфейс UI (user interface) это все, что позволяет человеку общаться с устройством или компьютером, следовательно, это способ сообщить устройству, что мы хотим, чтобы оно делало. Средствами реализации пользовательского интерфейса чаще всего выступают такие инструменты, как: клавиатура компьютерная мышь джойстик дисплей стилус.
2. Графический интерфейс GUI (graphical user interface) или графический интерфейс пользователя. Это система взаимодействия, предоставляющая пользователям доступ к системным объектам и инструментам управления через визуализацию информации – через графические элементы на мониторе. Чаще всего для экранного отображения команд и результатов их выполнения используются окна. Элементы управления программами отображаются визуально внутри окон – в форме: значков иконок кнопок меню списков полей ввода и прочих Управление этими элементами осуществляется с помощью средств реализации, указанных выше – например, с помощью мыши или сенсорного дисплея. Так как различные программы в рамках одной ОС используют идентичные визуальные элементы управления, процесс освоения новых программ для пользователей максимально упрощен. Они учатся на основе ранее полученного опыта. Пример GUI, с которым мы сталкиваемся ежедневно – web-интерфейс. Это любой интернет-браузер, через который мы читаем новости, делаем покупки, смотрим погоду и заказываем пиццу. С его помощью мы взаимодействуем с другими сайтами – программами в интернете. Каждый сайт тоже имеет свой интерфейс, через который система взаимодействует с вами. И это тоже графический web-интерфейс. 
3. Текстовый интерфейс TUI (англ. Text user interface) или текстовый интерфейс пользователя. Это система взаимодействия человека и машины посредством команд и откликов с помощью набора буквенно-цифровых символов – текста.   Лучший пример TUI – командная строка. Это прямой способ диалога с ОС. Он характеризуется низкой требовательностью к ресурсам и высокой скоростью отклика. Имеет немало преимуществ перед GUI в части удобства использования, поэтому алгоритмы с текстовым интерфейсом пишутся и сегодня. Прежде всего, для профессиональных программ и оборудования с низкой производительностью.  Недостаток TUI – ограниченность изобразительных средств. Его могут использовать лишь подготовленные пользователи, имеющие специальные знания. Чтобы команды работали, они должны быть введены точно и без ошибок. Для повышения юзабилити многие профессиональные программы используют интерактивные элементы, за счет которых создают более дружественную среду для работы.  
4. Жестовый интерфейс  Это технология взаимодействия, использующая в качестве средств ввода устройства, которые понимают команды при помощи жестов. Главный мотив реализации такого интерфейса – уход от традиционных компьютерных меню приложений с целью повышения юзабилити и эргономичности управления.   Реализацию таких интерфейсов можно встретить в смартфонах и планшетных ПК с сенсорным экраном, в ноутбуках с тачпадами и прочих устройствах. В них реализована технология считывания координат с нескольких точек – так называемый мультитач (multitouch). Второй пример – жесты мышью/джойстиком, которые алгоритм преобразует в команды. Третий – охранные системы, которые реагируют на движение. Жесты могут считываться в пространстве или на поверхности устройства, с помощью рук или головы, могут совершаться пультом или перчаткой – все это жестовый интерфейс. Он бывает контактным (тактильным) и бесконтактным. Он сложен в реализации, но легок в использовании и интуитивно понятен пользователям.  
5. Голосовой интерфейс  Это средство бесконтактного взаимодействия человека с машиной, где инструментом для ввода выступает микрофон и программа распознавания голосовых сообщений. Раньше это было чем-то из разряда научной фантастики. Сегодня голосовой интерфейс можно встретить в поисковиках, приложениях на смартфонах, мобильных виртуальных помощниках. «Окей, Гугл», «Alexa» от Амазон – все из этой оперы.   Но это хорошие примеры. На самом деле, реализация голосового интерфейса связана с определенными сложностями. Люди не привыкли терпеть «машину, которая не понимает». Поэтому любое устройство или программа с голосовым интерфейсом должна работать безупречно. При реализации этой технологии должны учитываться когнитивная модель целевой аудитории, решаемые задачи, процессы, которые нужно автоматизировать.
6. Интерфейс программ API (англ. application programming interface) или программный интерфейс приложений. Это инструменты взаимодействия компьютерных программ между собой. Функции и структуры программных объектов прописаны специальными алгоритмами. Часто выполнены как отдельная библиотека данных ОС, используются в интернет-протоколах, в описании структур приложений. API описывает абстракцию функциональности программных объектов и по модели реализации является аналогом протокола.    API это некий программный компонент, который помогает разработчикам вставлять вызовы исполняемых кодов одних программ в коды других объектов. Такая технология позволяет взаимодействовать программам, созданным разными разработчиками. Общий стандарт API помогает алгоритмам, написанным на разных языках программирования, обмениваться сообщениями, командами, иными сигналами. Это может происходить как в пределах одного ПК, так и в рамках компьютерной сети.  
7. Интерфейс программ с машинами Взаимодействие между программами и компьютерами, оборудованием и другими машинами реализовано с помощью операционных систем. Они контролируют  работу исполняемых кодов программ и драйверов, передавая команды центральному процессору машин. Например, смартфон. На него установлено множество приложений – мессенджеры, игры, почта, погода и масса других. Все они взаимодействуют с телефоном через операционную систему – Android или iOS. Не было бы операционной системы – приложение не получилось бы установить на гаджет.  
8. Аппаратный интерфейс Взаимодействие машин, компьютеров, оборудования и их компонентов обеспечивает интерфейс аппаратных средств. Он реализован с помощью кабелей, проводов, разъемов, шин и прочих контактных технических портов. Например, основные компьютерные устройства и их компоненты подключаются к ПК через USB.. Это принтеры, устройства ввода, флэшки. Не менее широкое применение находят инструменты бесконтактной коммуникации, такие как Wi-Fi или Bluetooth. Часто их совмещают с контактными. Например, беспроводные компьютерные мыши, принимающий модуль которых подключается через USB.

## 10. Аутентификация и авторизация

Идентификация - процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе (логин).

Аутентификация - процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.

Авторизация - предоставление определенному лицу или группе лиц прав на выполнение определенных действий.

Популярные методы аутентификации:
- Проверка подлинности на основе пароля (Password-based authentication) - это простой метод проверки подлинности, требующий ввода пароля для подтверждения личности пользователя.
- Беспарольная аутентификация (Passwordless authentication) - это когда пользователь проверяется с помощью одноразового ПИН-а (OTP - One-time pins) или magic link, доставленной на зарегистрированный адрес электронной почты или номер телефона;
- Для двухфакторной аутентификации/многофакторной аутентификации (2FA/MFA) требуется более одного уровня безопасности, например дополнительный PIN-код или контрольный вопрос, для идентификации пользователя и предоставления доступа к системе;
- Единый вход (SSO) позволяет пользователям получать доступ к нескольким приложениям с одним набором учетных данных;
- Социальная аутентификация (Social authentication) проверяет и аутентифицирует пользователей с существующими учетными данными на платформах социальных сетей.
- Биометрия (Biometrics) - пользователь предъявляет отпечаток пальца или скан глаза, чтобы получить доступ к системе.

Популярные методы авторизации:
- Управление доступом на основе ролей (RBAC - Role-based access controls) может быть реализовано для управления привилегиями от системы к системе и от пользователя к системе.
- Веб-токен JSON (JWT - JSON web token) - это открытый стандарт для безопасной передачи данных между сторонами, а пользователи авторизуются с помощью пары открытый/закрытый ключ.
- SAML - это стандартный формат единого входа (SSO), в котором аутентификационная информация передается через XML-документы с цифровой подписью.
- Авторизация OpenID проверяет личность пользователя на основе аутентификации сервера авторизации;
- OAuth позволяет API аутентифицировать и получать доступ к запрошенной системе или ресурсу.

## 11. ip-адреса. Идентификация ресурсов в сети. DNS

Вся интернет сеть подразделяется на глобальную (WAN) и локальную (LAN).

Все пользовательские устройства в рамках одной квартиры или офиса или даже здания (компьютеры, смартфоны, принтеры/МФУ, телевизоры и т.д.) подключаются к роутеру, который объединяет их в локальную сеть. Участники одной локальной сети могут обмениваться данными между своими устройствами без подключения к интернет провайдеру. А вот чтобы выйти в сеть (например, выйти в поисковик Яндекс или Google, зайти в VK, Instagram, YouTube или AmoCRM) необходим доступ к глобальной сети.

Каждое устройство в сети имеет свой уникальный IP-адрес. Он нужен для того, чтобы устройства сети понимали куда необходимо направить запрос и ответ. Для выхода в глобальные сети, ваш локальный ip-адрес подменяется роутером на глобальный, который вам выдал провайдер. Локальные ip-адреса - это серые ip-адреса, а глобальные - это белые.

IP-адрес (интернет-протокол) – это идентификатор, позволяющий передавать информацию между устройствами в сети: он содержит информацию о местоположении устройства и обеспечивает его доступность для связи. IP-адреса позволяют различать компьютеры, маршрутизаторы и веб-сайты в интернете и являются важным компонентом работы интернета.

IPv4 (Internet Protocol version 4) используется число из 32 бит, ограничивающие адресное пространство (232 возможными уникальными адресами). Традиционной формой записи IPv4-адреса является запись в виде четырёх десятичных чисел (от 0 до 255), разделенных точками.

IPv6 (Internet Protocol version 6) используется число из 128 бит,  ограничивающие адресное пространство (1028 возможными уникальными адресами). Традиционной формой записи IPv6-адреса является запись в виде 8 групп шестнадцатеричных чисел, разделенных двоеточиями.

Так почему бы просто не перейти на IPv6? Основная причина — стоимость. Для обновления всех серверов, маршрутизаторов и коммутаторов, которые всё это время зависели только от IPv4, требуется уйма денег и времени в таком случае приходит на помощь технология NAT (Network address translation), а точнее её надстройка PAT (Port address translation) - суть заключается в том что много устройств могут выходить в сеть с одним и темже адресом.

Статический IP-адрес (он же постоянный, внешний) – это фиксированный IP-адрес, который назначен провайдером при подключении к интернету на неограниченное время. Главное отличие статического IP-адреса от динамического состоит в том, что динамический IP-адрес может меняться при каждом новом интернет-подключении.

Внутренним (локальным). Так называют адрес, используемый только в пределах одной локальной сети. Внешним (реальным, глобальным). Это уникальный адрес, под которым компьютер виден прочим устройствам в глобальной сети.

Простыми словами о сложном: https://www.youtube.com/watch?v=6tFGoiok0u8

(URI – имя и адрес ресурса в сети, включает в себя URL и URN) = (URL – адрес ресурса в сети, определяет местонахождение и способ обращения к нему) + (URN – имя ресурса в сети, определяет только название ресурса, но не говорит как к нему подключиться)

![image](https://user-images.githubusercontent.com/88891623/187666539-eb2ec85f-a5d4-48cb-8fdc-b2c533dea3c3.png)

Синтаксис URI (Пример: http://www.test.com:80/path/to/myfile.htmlkey1=value1&key2=value2#SomewhereInTheDocument):

1. http:// - это пример протокола (схемы). Тут описывается какой протокол браузер должен использовать. Обычно это HTTP протокол или его безопасная версия - HTTPS. Интернет требует один из этих двух, но браузеры также знают как работать с некоторыми другими, например mailto: (чтобы открыть почтовый клиент) или ftp: для работы с передачей файлов.
2. www.test.com - это доменное имя, идентификатор ответственного за это пространство имён. Идентифицирует, какой именно Веб-сервер получает запрос. Альтернативно, можно просто использовать IP address, но поскольку это не так удобно, то этот способ используется не часто.
3. :80 - это порт сервера. Он идентифицирует технические "ворота", которые нужны для доступа к ресурсу на сервере. Обычно порт не указывается, т.к. существуют общепринятые нормы о стандартных портах для HTTP (80 для HTTP и 443 для HTTPS). В других случаях обязательно нужно указывать.
4. /path/to/myfile.html - это путь к ресурсу на Веб-сервере. Изначально путь типа этого указывал на физическое место файла на сервере, но сейчас всё чаще это псевдоним или описание некоторого абстрактного ресурса.
5. key1=value1&key2=value2 - это дополнительные параметры (query parameters), предоставляемые Веб-серверу. Это список пар "ключ=значение", разделенных символом & . Веб-сервер может использовать эти параметры как дополнительные инструкции, что именно сделать с ресурсом перед отправкой его пользователю. Каждый Веб-сервер имеет свои правила насчет параметров, и единственный надежный способ узнать как конкретный Веб-сервер обрабатывает эти параметры - это спросить того, кто контролирует Веб-сервер.
6. #SomewhereInTheDocument - это "якорь" на другую часть ресурса. Якорь представляет собой что-то вроде "закладки" внутри ресурса, давая браузеру указание показать содержимое с определённого места. В HTML-документе, к примеру, браузер будет скроллить к точке где якорь определён, а на аудио/видео-документе браузер попытается перейти на время, указанное в якоре. Важно что часть, начинающаяся с # - никогда не пересылается серверу в запросе.

DNS (Domain name system) — это система, преобразующая человекочитаемые доменные имена в IP-адреса, понимаемые машиной. Как только нужная DNS-запись найдена, браузер получает IP-адрес, на который посылает запрос. В ответ приходит web-страница.

## 12. Клиент - серверная архитектура. Тонкий и тостый клиент
Клиент-серверная архитектура – это такая архитектура, которая распределяет сетевую нагрузку между сервером и клиентом.

Клиент – локальный компьютер, который выполняет отправку запроса к серверу для возможности выполнения определенных системных действий.

Сервер – очень мощный компьютер, который предназначается для разрешения определенного круга задач по процессу выполнения программных кодов. Он выполняет работы сервисного обслуживания по клиентским запросам, предоставляет пользователям доступ к определенным системным ресурсам, сохраняет данные или БД.

Архитектуру «клиент-сервер» принято разделять на три класса: одно-, двух- и трехуровневую:
1. Одноуровневая архитектура «клиент-сервер» (1-Tier) - такая, где все прикладные программы рассредоточены по рабочим станциям, которые обращаются к общему серверу баз данных или к общему файловому серверу. Никаких прикладных программ сервер при этом не исполняет, только предоставляет данные;
2. К двухуровневой архитектуре «клиент-сервер» следует относить такую, в которой прикладные программы сосредоточены на сервере приложений (Application Server), например, сервере 1С или сервере CRM, а в рабочих станциях находятся программы-клиенты, которые предоставляют для пользователей интерфейс для работы с приложениями на общем сервере;
3. В трехуровневой архитектуре сервер баз данных, файловый сервер и другие представляют собой отдельный уровень, результаты работы которого использует сервер приложений. Логика данных и бизнес-логика находятся в сервере приложений. Все обращения клиентов к базе данных происходят через промежуточное программное обеспечение (middleware), которое находится на сервере приложений. Вследствие этого, повышается гибкость работы и производительность.

Тонкий клиент – это компьютер или программа-клиент в клиент-серверной архитектуре, которая переносит всё или большую часть задач по обработке информации на сервер (пример: браузер используется для работы с веб-приложениями т.к. основная бизнес-логика и мощности расположены на сервере, а клиент просто отправляет запросы на сервер). 

Толстый клиент – это приложение, обеспечивающее расширенную функциональность независимо от центрального сервера. Часто сервер в этом случае является лишь хранилищем данных, а вся работа по обработке и представлению этих данных переносится на машину клиента (пример: 1С бухгалтерия, онлайн игры).

## 13. Эталонные модели OSI и TCP/IP. Виды сетевых протоколов
Стек протоколов TCP/IP (Transmission Control Protocol/Internet Protocol, протокол управления передачей/протокол интернета) — сетевая модель, описывающая процесс передачи цифровых данных. В модели предполагается прохождение информации через четыре уровня.
Уровни TCP/IP:
1. Канальный уровень (link layer) - задача дать описание тому, как происходит обмен информацией на уровне сетевых устройств, определить, как информация будет передаваться от одного устройства к другому. Информация здесь кодируется, делится на пакеты и отправляется по нужному каналу;
2. Межсетевой уровень (internet layer) – задача объединение локальных сетей в глобальную, благодаря чему открывается возможность взаимодействия разных сетей. (IP, ARP, ICMP, IGMP)
3. Транспортный уровень (transport layer) — предназначен для доставки данных. Протоколы TCP и UDP, занимаются доставкой информации:
TCP (протокол управления передачей) — надежный, он обеспечивает передачу информации, проверяя дошла ли она, насколько полным является объем полученной информации и т.д.
UDP (протокол пользовательских датаграмм) — ненадежный, он занимается передачей датаграммы они содержат всю необходимую информацию, чтобы дойти до получателя, но они все равно могут быть потеряны или доставлены в порядке отличном от порядка при отправлении.
Датаграмма — блок информации, передаваемый протоколом через сеть связи без предварительного установления соединения и создания виртуального канала.
4. Прикладной уровень (application layer) - обеспечивает взаимодействие сети и пользователя. Уровень разрешает приложениям пользователя иметь доступ к сетевым службам, таким, как обработчик запросов к базам данных, доступ к файлам, пересылке электронной почты. (HTTP, FTIP, NTP, DHCP и др.)
 
Сетевая модель OSI — посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом. Модель определяет различные уровни взаимодействия систем. Каждый уровень выполняет определённые функции при таком взаимодействии.
Уровни OSI:
1. Физический уровень (physical layer) - отвечает за передачу необработанных битов по каналу связи между физическими устройствами (железом) по проводам (оптоволокно) или без проводов (Bluetooth, Wi-Fi, GSM, 4G и так далее).
2. Канальный уровень (data link layer) - второй уровень решает проблему адресации при передаче информации.
3. Сетевой уровень (network layer) - занимаются построением маршрута от одного устройства к другому с учетом всех потенциальных неполадок в сети.
На сетевом уровне активно используется протокол ARP (Address Resolution Protocol — протокол определения адреса). С помощью него 64-битные MAC-адреса преобразуются в 32-битные IP-адреса и наоборот; (IP, ARP, ICMP, IGMP)
4. Транспортный уровень (transport layer) - предназначен для доставки данных. При этом неважно, какие данные передаются, откуда и куда, то есть, он предоставляет сам механизм передачи.
(TCP, UDP)
5. Cеансовый уровень (session layer) - сеансовый уровень отвечает за поддержку сеанса или сессии связи; (HTTP, HTTPS, FTIP, NTP, DHCP и др.)
6. Представления уровень (presentation layer) - представляет данные (которые все еще являются PDU) в понятном человеку и машине виде. Например, когда одно устройство умеет отображать текст только в кодировке ASCII, а другое только в UTF-8, перевод текста из одной кодировки в другую происходит на шестом уровне. (HTTP, HTTPS, FTIP, NTP, DHCP и др.)
7. Прикладной (application layer) - это то, с чем взаимодействуют пользователи, своего рода графический интерфейс всей модели OSI, с другими он взаимодействует по минимуму. Задача седьмого уровня — использовать свои протоколы, чтобы пользователь увидел данные в понятном ему виде.
Протоколы здесь используют UDP (например, DHCP, FTP) или TCP (например, HTTP, HTTPS, SFTP (Simple FTP), DNS).

Протокол – это набор правил передачи информации. С помощью протоколов мы регламентируем то как наша информация будет передаваться в сети интернета.

Виды сетевых протоколов:
- TCP – обеспечивает надежную доставку сегментов и их упорядочивание, контроль скорости передачи данных, работа с сессиями; 
- IP – протокол, в функции которого входит корректность доставки сообщений по выбранному адресу;
- MAC – вид протокола, на основании которого происходит процесс верификации сетевых устройств. Все устройства, которые подключены к сети Интернет, содержат свой оригинальный MAC-адрес;
- ICMP – протокол, который ответственен за обмен данными, но не используется для процесса передачи информации;
- UDP – протокол, управляющий передачей данных, но данные не проходят верификацию при получении. Этот протокол функционирует быстрее, чем протокол TCP;
- HTTP – протокол для передачи информации (гипертекста), на базе которого функционируют все сегодняшние сайты;
- FTP – протокол передачи информации из особого файлового сервера на ПК конечного пользователя;
- POP3 – классический протокол простого почтового соединения, который ответственен за передачу почты;
- SMTP – вид протокола, который может устанавливать правила для передачи виртуальной почты. Он ответственен за передачу и верификацию доставки, а также оповещения о возможных ошибках;
- SSH - В основном используют для удаленной работы с серверами, а также для надежного переноса большого количества данных. Например, при смене хостинг-провайдера и переносе сайта от одного хостера к другому, для быстрой организации процесса вам понадобится именно SSH доступ к старому хостингу. 

## 14. HTTP-протокол. Методы HTTP
http / https (HyperText Transfer Protocol «протокол передачи гипертекста») – это один и тот же протокол для передачи данных, разница в том что https защищён и на передачу и на получение данных. http работает по порту 80, а https по порту 443.

Структура HTTP-сообщения
Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:
1. Стартовая строка (Starting line) - определяет тип сообщения, различается для запроса и ответа;

2. Заголовки (Headers) - характеризуют тело сообщения, параметры передачи и прочие сведения;

3. Тело сообщения (Message Body) - непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Запрос посылает клиент на сервер, а сервер реагирует на запрос и отдаёт свой HTTP response (ответ) Из чего состоят запросы и ответы: 
- HTTP request состоит из: метод, версия протокола, URL (к какому ресурсу мы обращаемся (может не быть)), Host (там где находится наш сервер), Headers (служебная информация может быть, а может и нет);
- HTTP response состоит из: версия протокола, статус код (успешность ответа сервера), status message (статус код имеет текстовую информацию), дата (когда был отправлен ответ от сервера), информация о сервере, Headers (опять же характеризуют нашу основную нагрузку) так-же если ответ содержит в себе какую-то полезную нагрузку, то будет ещё информация с ней (например документ в формате html).

Методы HTTP запроса:
- GET - используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса. Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»
- HEAD - аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.
- POST - применяется для передачи пользовательских данных заданному ресурсу. С помощью метода POST обычно загружаются файлы на сервер.
- PUT происходит отправка информации на сервер и используется чтобы создавался какой-то объект на сервере. различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу;
- PATCH - аналогично PUT, но применяется только к фрагменту ресурса.
- DELETE - удаляет указанный ресурс;
- CONNECT - преобразует соединение запроса в TCP/IP-туннель, обычно чтобы содействовать установлению защищённого соединения через нешифрованный прокси.
- OPTIONS - используется для описания параметров соединения с ресурсом.
- TRACE - возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.

## 15. Веб-сервисы

Веб-сервисы, веб-службы – это веб ориентированная технология которая помогает программам общаться между собой использую форматы XML и JSON и посредством протокола SOAP и архитектурного стиля REST.

Протокол SOAP
SOAP (Simple Object Access Protocol — простой протокол доступа к объектам) — протокол обмена структурированными сообщениями в распределённой вычислительной среде. Протокол используется для обмена произвольными сообщениями в формате XML. Используется в веб-сервисах.
XML (Xtensible Markup Language — расширяемый язык разметки) – язык разметки документов, позволяющий структурировать информацию разного типа (похож на HTML)
Разница между XML и HTML: HTML заботится об отображении информации, а XML о транспортировке информации.
 
В рамках SOAP: для передачи информации используется XML файлы (поддерживает только XML)
XSD (XML schema definition) – описывает структуру нашего xml документа и типы данных которые там могут хранится (веб сервисе у нас есть данный файл XSD и с помощью него мы можем задавать различные элементы, данные внутри XML и передавать их посредством сети интернета.
Правила для написания XML документа
WSDL (Web services description language) – это файл c таким расширением с таким форматом написанный на языке WSDL он описывает сообщения, заголовки, события которые свойственны для нашего веб сервиса т.е. данный файл описывает структуру нашего веб-сервиса (обязателен для SOAP протокола) 
Разница между SOAP и REST – к архитектурному стилю не применяются какие-то жёсткие правила не нужны WSDL (бывает используется формат документа VADL но он не обязателен)
REST предпочитают использовать всё чаще т.к. этот архитектурный стиль позволяет записывать информацию в более удобном формате который занимает меньше места и повышает производительность нашей системы. Ему предъявляется меньше требований.


REST (Representational State Transfer) — архитектурный стиль c помощью которого описывается структура передачи информации, правил у веб сервисов.
RESTfull – явл. характеристикой наших веб-сервисов такие требования которые отвечают требованиям REST которые предъявляет этот архитектурный стиль.
Вывод: REST описывает структуру нашего веб-сервиса, а RESTfull это уже сам веб-сервис который отвечает требованиям REST.
 
В REST использует формат JSON (распространённый), но можно использовать и XML и текстовые форматы.
JSON (JavaScript Object Notation) — текстовый формат обмена данными, основанный на JavaScript.
В отличии от XML нет строгих правил, более гибкий, удобнее работать, занимает меньше места.
Документы в формате JSON состоят из объектов пар (имя – значение).
Типы данных в JSON:
{
    “array”: [  -  Массив JSON — это упорядоченный набор значений, который позволяет хранить  1,              	-  список значений. Массив начинается с левой квадратной скобки [ и завершается
2,              	-  правой квадратной скобкой ]. Его значения разделяются запятой.
3
],
“bolean” : true,  -  может быть true или false.
“color” : gold,
“null” : null,  -  пустой.
“number” : 123,  -  десятичное значение без лишнего начального нуля; может содержать цифры от 0 до 9. Число может быть отрицательным (-10), дробью (.5), а также может быть степенью 10 с префиксом e, E, + или -.
“object” : {  -  это неупорядоченный набор пар имя/значение, вставленных между фигурных
    “a” : “b”,	скобок. Объект может содержать ноль или несколько пар имя/значение, в таком
    “c” : “d” 	случае они разделяются запятыми.
    }
“string” : “Helloy World”  -  упорядоченное множество из нуля или более симвл. заключён в (“…”)
}
 
Заключение: Разница между SOAP и REST веб-сервисами:
1. REST поддерживает различные форматы (JSON (распространённый), но можно использовать и XML и текстовые форматы.). SOAP поддерживает только XML.
2. REST работает только по протоколам HTTP или HTTPS. SOAP в отличие может работать с различными протоколами.
3.SOAP на основе чтения не может быть помещён в кэш в отличии от REST который в таком случае может быть закэширован.
4. REST это архитектурный стиль у которого нету огромного количества правил, которым он должен подчиняться. SOAP это протокол который ограничен теми правилами которые к нему предъявляются.
 
Что лучше выбирать на проектах SOAP или REST – тут идёт выбор между простотой или стандартом в случае с REST у вас будет простота, скорость, расширяемость и поддержка многих форматов и нет привязки к тем правилам которые применяются к SOAP.
В случае с SOAP у вас будет больше возможностей по безопасности и так же будет возможность провести тестирование качественно т.к. будет WSDL где будут содержаться образцы наших запросов и не нужно будет обращаться к разработчику, просить его чтобы он предоставил вам информацию и какие-то примеры запросов. Можно сразу брать и тестировать. SOAP так же более ресурсоёмкий, занимает больше места, медленнее и в целом разработка с использованием SOAP дольше. 

## 16. Коды ответов сервера

- Информационный	100 Continue («продолжай»);
- 101 Switching Protocols («переключение протоколов»);
- 102 Processing («идёт обработка»);
- 103 Early Hints («ранняя метаинформация»).
____
- Успех	200 OK («хорошо»);
- 201 Created («создано»);
- 202 Accepted («принято»);
- 203 Non-Authoritative Information («информация не авторитетна»);
- 204 No Content («нет содержимого»);
- 205 Reset Content («сбросить содержимое»);
- 206 Partial Content («частичное содержимое»);
- 207 Multi-Status («многостатусный»);
- 208 Already Reported («уже сообщалось»);
- 226 IM Used («использовано IM»).
____
- Перенаправление	300 Multiple Choices («множество выборов»);
- 301 Moved Permanently («перемещено навсегда»);
- 302 Moved Temporarily («перемещено временно»), 
- 303 See Other («смотреть другое»)];
- 304 Not Modified («не изменялось»);
- 305 Use Proxy («использовать прокси»);
- 306 — зарезервировано (код использовался только в ранних спецификациях);
- 307 Temporary Redirect («временное перенаправление»);
- 308 Permanent Redirect («постоянное перенаправление»).
____
- Ошибка клиента	400 Bad Request («неправильный, некорректный запрос»);
- 401 Unauthorized («не авторизован (не представился)»);
- 402 Payment Required («необходима оплата»);
- 403 Forbidden («запрещено (не уполномочен)»);
- 404 Not Found («не найдено»);
- 405 Method Not Allowed («метод не поддерживается»);
- 406 Not Acceptable («неприемлемо»);
- 407 Proxy Authentication Required («необходима аутентификация прокси»);
- 408 Request Timeout («истекло время ожидания»);
- 409 Conflict («конфликт»);
- 410 Gone («удалён»);
- 411 Length Required («необходима длина»);
- 412 Precondition Failed («условие ложно»);
- 413 Payload Too Large («полезная нагрузка слишком велика»);
- 414 URI Too Long («URI слишком длинный»);
- 415 Unsupported Media Type («неподдерживаемый тип данных»);
- 416 Range Not Satisfiable («диапазон не достижим»);
- 417 Expectation Failed («ожидание не удалось»);
- 418 I’m a teapot («я — чайник»);
- 419 Authentication Timeout (not in RFC 2616) («обычно ошибка проверки CSRF»);
- 421 Misdirected Request [10];
- 422 Unprocessable Entity («необрабатываемый экземпляр»);
- 423 Locked («заблокировано»);
- 424 Failed Dependency («невыполненная зависимость»);
- 425 Too Early («слишком рано»);
- 426 Upgrade Required («необходимо обновление»);
- 428 Precondition Required («необходимо предусловие»);
- 429 Too Many Requests («слишком много запросов»);
- 431 Request Header Fields Too Large («поля заголовка запроса слишком большие»);
- 449 Retry With («повторить с»);
- 451 Unavailable For Legal Reasons («недоступно по юридическим причинам»).
- 499 Client Closed Request (клиент закрыл соединение)
____
- Ошибка сервера	500 Internal Server Error («внутренняя ошибка сервера»);
- 501 Not Implemented («не реализовано»);
- 502 Bad Gateway («плохой, ошибочный шлюз»);
- 503 Service Unavailable («сервис недоступен»);
- 504 Gateway Timeout («шлюз не отвечает»);
- 505 HTTP Version Not Supported («версия HTTP не поддерживается»);
- 506 Variant Also Negotiates («вариант тоже проводит согласование»);
- 507 Insufficient Storage («переполнение хранилища»);
- 508 Loop Detected («обнаружено бесконечное перенаправление»);
- 509 Bandwidth Limit Exceeded («исчерпана пропускная ширина канала»);
- 510 Not Extended («не расширено»);
- 511 Network Authentication Required («требуется сетевая аутентификация»);
- 520 Unknown Error («неизвестная ошибка»);
- 521 Web Server Is Down («веб-сервер не работает»);
- 522 Connection Timed Out («соединение не отвечает»);
- 523 Origin Is Unreachable («источник недоступен»);
- 524 A Timeout Occurred («время ожидания истекло»);
- 525 SSL Handshake Failed («квитирование SSL не удалось»);
- 526 Invalid SSL Certificate («недействительный сертификат SSL»).

## 17. Типы мобильных приложений

Нативные приложения: написаны на родном для определенной платформы языке программирования. Для Android этим языком является Kotlin/Java, тогда как для iOS - objective-С или Swift. Нативные приложения находятся на самом устройстве, доступ к ним можно получить, нажав на иконку. Они устанавливаются через магазин приложений (Play Market на Android, App Store на iOS и др.). Они разработаны специально для конкретной платформы и могут использовать все возможности устройства - камеру, уведомления и т.п. (при наличии разрешений). В зависимости от предназначения нативного приложения, оно может всецело или частично обходиться без наличия интернет-соединения;

Веб-приложения: на самом деле не являются приложениями как таковыми. В сущности, они представляют собой сайты, которые адаптированы и оптимизированы под любой смартфон и выглядят похоже на нативное приложение. И для того, чтобы воспользоваться им, достаточно иметь на устройстве браузер, знать адрес и располагать интернет-соединением. Запуская мобильные веб-приложения, пользователь выполняет все те действия, которые он выполняет при переходе на любой веб-сайт, а также получает возможность «установить» их на свой рабочий стол, создав закладку страницы веб-сайта. Веб-приложения отличаются кроссплатформенностью, то есть способны функционировать, независимо от платформы девайса. Очевидным недостатком такого вида приложений является утрата работоспособности при потере интернет-соединения. Причем из этого выплывает и другой минус - их производительность, которая находится на среднем уровне, в сравнении с другими видами приложений и зависит от возможностей интернет-соединения провайдера услуг. Помимо вышеперечисленного, веб-приложения не могут получить доступ к функциям системы и самого устройства;

Гибридные приложения: это веб-приложение в обертке нативного приложения, что служит контейнером для отображения веб-приложения через встроенный упрощенный браузер (webview в Android(Chrome webview в последней версии) и WKWebView в iOS). Нативный “фундамент” даёт преимущества нативных приложений: доступ к функционалу смартфона (API системы, пуши и т.п.), размещение в маркетах, иконка на рабочем столе и т.п., а сторона веб-приложений дает плюсы в виде кроссплатформенности и простоты обновления контента. Компания, имеющая веб-приложение, может практически “на коленке” собрать гибридные приложения для основных платформ и обеспечить себе присутствие в маркете и на рабочем столе клиентов;

PWA: технология в web-разработке, которая визуально и функционально трансформирует сайт в приложение (мобильное приложение в браузере).
PWA является гибридным решением и позволяет открыть приложение с помощью мобильного браузера. При этом полностью сохраняется функциональность нативного приложения:
- отправка push-уведомлений (кроме устройств под управлением iOS);
- работа в режиме офлайн;
- доступ к аппаратному обеспечению устройства (с ограничениями);
- установка ярлыка (иконки) на рабочий стол мобильного устройства, визуально не отличающегося от ярлыка нативного приложения, и пр.

## 18. Симуляторы и эмуляторы

Эмулятор: пытается дублировать устройство - это полноценная виртуалка (контейнер) со своей сетевой картой и диском, то есть представляет собой полную повторную реализацию конкретного устройства или платформы изолированно внутри нашей хост-системы. Одним из недостатков такого подхода является скорость работы. Примером служит эмулятор в Android Studio, хотя можно найти и неофициальные эмуляторы и образы Android-устройств.

Симулятор: пытается дублировать только поведение устройства. Как правило, симулятор - это имитация лишь отдельных свойств, возможностей или функций симулируемой системы, причем не в полном объеме, а только в том, в каком это необходимо в рамках тех задач, которые были поставлены перед симулятором. Вы как будто бы работаете с настоящим устройством, но при этом под капотом оно является лишь ПО-имитацией, не работающей изолированно от нашей системы и использующей общий диск и сеть. Примером служит симулятор в XCode.

